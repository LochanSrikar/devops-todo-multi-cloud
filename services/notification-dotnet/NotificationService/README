# Notification Microservice (.NET with ASP.NET Core)

This is the Notification microservice for event-driven alerts in the Todo app. It receives task data from Todo and "sends" notifications (simulated with console log; can extend to email). Built with ASP.NET Core for fast API.

## Setup
- Make sure you have .NET 8.0 SDK installed for development.
- The service runs on port 5098 (or as shown in run logs).
- Test endpoint: POST http://localhost:5098/notify with body like {"task": "Test"} (returns "Notified").

## Docker Commands to Run the Container

These commands containerize and run the Notification service. Run them in the `services/notification-dotnet/NotificationService` folder.

| Order | Command | Description | Why Needed | Example Usage |
|-------|---------|-------------|------------|--------------|
| 1 | `dotnet publish -c Release -o out` | Publishes the .NET app to an "out" folder for optimized files. | Prepares the app package (DLLs) for the container—makes it ready to run without full SDK. Significance: Optimizes for production; keeps container light. | Run in `NotificationService` folder. |
| 2 | `docker build -t notification-service .` | Builds the container image from the Dockerfile. | Creates the "box" with your .NET app and runtime—first step to containerize. Significance: Makes the app portable; run it anywhere with Docker. | Run after publish. |
| 3 | `docker run -d -p 5098:80 notification-service` | Runs the container in background, mapping port 80 inside to 5098 on PC. | "Opens" the box to start the app and access it. Significance: Tests if the container works like local; -d keeps terminal free. | Run after build; adjust port if needed; stop with `docker stop <ID>`. |
| 4 | `docker ps` | Lists running containers. | Checks what's active. Significance: Debug if your app is up. | Run anytime. |
| 5 | `docker ps -a` | Lists all containers (running or stopped). | Sees stopped ones too. Significance: Find old containers for logs. | Use if `docker ps` is empty. |
| 6 | `docker logs <CONTAINER ID>` | Shows logs from a container (get ID from `docker ps -a`). | "Peeks inside" for errors or alerts. Significance: Debugging tool. | e.g., `docker logs 511e31e9ca25`. |
| 7 | `docker stop <CONTAINER ID>` | Stops a running container. | "Puts the toy away"—frees resources. Significance: Clean up to avoid conflicts. | e.g., `docker stop 511e31e9ca25`. |
| 8 | `docker images` | Lists built images. | Sees your "blueprints." Significance: Verify builds. | Run after build.

## How to Run Locally (Without Docker)
- `dotnet restore` (install dependencies).
- `dotnet build` (compile).
- `dotnet run` (start on port 5098 or as shown).
- Test: Use PowerShell for POST as in the project guide.

## Notes
- The Dockerfile uses .NET runtime for a small size.
- Integrate with Todo: Run this service, then Todo calls it on task add (update port in app.py if needed).
- For full app: Run with Todo and User containers for end-to-end testing.

-------------------------------------------------------------------------------------------------------------------------------------------------------
## How We Created ECR, Tagged, and Pushed the Docker Image

ECR (AWS Elastic Container Registry) is a secure "warehouse" for storing Docker images in the cloud. We created a repo for the Notification service, tagged the local image, and pushed it. This makes the image shareable and deployable in AWS (e.g., EKS in Level 5). Why this? Local images are on your PC—pushing to ECR is like uploading photos to cloud storage for backup and sharing. Significance: Enables multi-cloud (AWS + Azure) and automated deploys (Level 3 CI/CD)—saves time, ensures consistency.

### Step-by-Step Process
1. **Create ECR Repository (The Warehouse Shelf)**:
   - Command: `aws ecr create-repository --repository-name notification-service --region us-east-1`
   - Why Needed: ECR needs a "shelf" (repo) for your image—can't store without it.
   - Significance: Private for security (DevSecOps Level 7)—protects code. Defaults are free-tier safe. Verification: Copy "repositoryUri" from output (e.g., 288761730775.dkr.ecr.us-east-1.amazonaws.com/notification-service).

2. **Tag the Image (Label the Box for Shipping)**:
   - Command: `docker tag notification-service:latest <repositoryUri>:latest` (replace <repositoryUri> with your URI).
   - Why Needed: Tags "addresses" the image for the repo—Docker needs this to know where to send.
   - Significance: Allows versioning (:latest, :v1)—tracks updates like Git tags (Level 2).

3. **Login to ECR (Get the Key to the Warehouse)**:
   - Command: `aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin <account>.dkr.ecr.us-east-1.amazonaws.com`
   - Why Needed: ECR requires "login" to push—like a key for the door.
   - Significance: Secure access—token expires soon (Level 7 safety).

4. **Push the Image (Ship the Box)**:
   - Command: `docker push <repositoryUri>:latest`
   - Why Needed: Uploads the tagged image to ECR.
   - Significance: Image is now cloud-stored—pull from anywhere (e.g., EKS in Level 5).

5. **Verification (Check the Warehouse)**:
   - Console: AWS > ECR > Repositories > notification-service > Images—see "latest".
   - Why Needed: Confirms no issues during push.
   - Significance: Debugging habit—catch problems early (Level 6 monitoring).